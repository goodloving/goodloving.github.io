(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{329:function(e,s,t){"use strict";t.r(s);var n=t(33),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"async、await与promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async、await与promise"}},[e._v("#")]),e._v(" async、await与promise")]),e._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#_1-promise详解"}},[e._v("1.Promise详解")])]),t("li",[t("a",{attrs:{href:"#_2-async和await详解"}},[e._v("2.async和await详解")])]),t("li",[t("a",{attrs:{href:"#_3-总结与分析"}},[e._v("3.总结与分析")])])])]),t("p"),e._v(" "),t("h2",{attrs:{id:"_1-promise详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-promise详解"}},[e._v("#")]),e._v(" 1.Promise详解")]),e._v(" "),t("p",[t("strong",[e._v("==Promise是对异步编程的一种解决方案==")]),e._v("\n  Promise是一个构造函数，自身有all、reject、resolve这几个方法，原型上有then、catch等方法。Promise的构造函数接收一个函数作为参数，并且在函数中传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其中resolve将Promise的状态置为fullfiled，reject将Promise的状态置为rejected。，接下来直接看代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log('start')\n\nvar p = new Promise((resolve, reject) => {\n  console.log('enter Promise')\n  //异步操作\n  setTimeout(() => {\n    console.log('time out')\n    console.log(reject)\n    //执行失败的回调函数，将会在catch中进行接收\n    reject(123456)\n  },3000)\n})\n\np.then(r => {\n  console.log(r)\n  console.log('promise then')\n})\n\np.catch(e => {\n  console.log(e)\n  console.log('promise catch')\n  console.log(p)\n})\n\nconsole.log(p)\nconsole.log('end')\n")])])]),t("p",[e._v("代码中用setTimeout模拟异步的操作。我们先来观察打印出来的结果：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("start\nenter Promise\nPromise { <pending> }\nend\ntime out\n[Function]\n123456\npromise catch\nPromise { <rejected> 123456 }\n")])])]),t("p",[e._v("根据结果分析程序运行的顺序探讨Promise的执行过程：\n"),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190922165719886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTY3OTg1,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),e._v("\n  从上述代码的执行顺序来看，==无论是Promise内部还是处于同一级的其他其他代码，只要是非异步耗时操作都会按顺序在主线程执行==，例如，结果中\t"),t("code",[e._v("1.start 2.enter Promise 3.Promise { <pending> } 4.end")]),e._v("其中"),t("code",[e._v("2.enter Promise")]),e._v("处在Promise内部但是并不是耗时的异步操作，故直接执行不需要等待；接着程序执行到setTimeout定时任务的异步耗时操作，进入任务队列中等待（后面文章将会进行详解），主线程依次执行完"),t("code",[e._v("3.Promise { <pending> } 4.end")]),e._v("，此时主线程为空，即没有代码在执行，任务队列得知主线程为空就会开始执行，于是3秒后执行代码"),t("code",[e._v("5.time out 6.[Function]")]),e._v("，通过reject返回结果回调执行.catch，再依次执行"),t("code",[e._v("7.123456 8.promise catch 9.Promise { <rejected> 123456 }")]),e._v("。\n  同时，可以观察到，当Promise中的异步耗时还没有执行，即没有调用resolve和reject时，打印出Promise状态为"),t("code",[e._v("{ <pending> }")]),e._v("，当调用resolve返回结果时打印Promise状态为"),t("code",[e._v("{ <rejected> 123456 }")]),e._v("，当然当调用resolve是Promise状态为"),t("code",[e._v("{ <fulfilled> }")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_2-async和await详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-async和await详解"}},[e._v("#")]),e._v(" 2.async和await详解")]),e._v(" "),t("p",[e._v("  async 用来定义一个返回 AsyncFunction 对象的异步函数，==它会通过一个隐式的 Promise 返回其结果==。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。返回的Promise对象会运行执行(resolve)异步函数的返回结果，或者运行拒绝比如异步函数抛出异常的话，运行执行(reject)异步函数的返回结果。await可以是Promise同步，即不会立即执行Proimse外面(或者说下面)的代码，而await只能用在async标记的函数中，"),t("strong",[e._v("==这样async函数本身就是异步的，而async函数里面的代码是同步的==")]),e._v("。async本身是异步的，可以这样理解，"),t("strong",[e._v("async函数执行到await的时候就立即await修饰的代码，并返回结果")]),e._v("。async下面的代码，与await等待执行的代码同时执行。（说起来有点拗口），直接看代码和结果分析：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function resolveAfter2Seconds() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log('time out')\n      resolve('resolved');\n    }, 2000);\n  });\n}\n/**\n * async + await */\nasync function asyncCall() {\n  console.log('before');\n  var result = await resolveAfter2Seconds();\n  console.log(result);\n  console.log('after');\n}\n\n/**\n * 正常函数 */\nfunction call() {\n  console.log('before');\n  var result = resolveAfter2Seconds();\n  console.log(result);\n  console.log('after');\n}\n\nconsole.log('start')\n asyncCall();\n//call();\nconsole.log('end')\n")])])]),t("p",[e._v("首先注释掉"),t("code",[e._v("//call();")]),e._v("，结果为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("start\nbefore\nend   \ntime out\nresolved\nafter\n")])])]),t("p",[e._v("然后换成注释掉"),t("code",[e._v("//asyncCall();")]),e._v("，结果为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("start\nbefore\nPromise { <pending> }\nafter\nend\ntime out\n")])])]),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190922175810259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTY3OTg1,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),e._v("\n分析：对于async修饰的函数，当用await进行结果修饰时result会等待"),t("code",[e._v("resolveAfter2Seconds()")]),e._v("执行完毕并且得到其结果，然后再执行")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(result);\nconsole.log('after');\n")])])]),t("p",[e._v("同时观察到打印出来的resulit为"),t("code",[e._v("resolved")]),e._v("，说明Promse返回不为空；当不用async和await时，观察发现，此时result打印出来为"),t("code",[e._v("Promise { <pending> }")]),e._v("说明此时的Promise为空，即异步结果还没有返回，最后才执行输出"),t("code",[e._v("time out")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_3-总结与分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结与分析"}},[e._v("#")]),e._v(" 3.总结与分析")]),e._v(" "),t("p",[t("strong",[e._v("==Promise和async、await都是作为异步编程的一种解决方案==")]),e._v("，有时候程序执行异步操作时，如果其后面代码的运行依赖返回的结果，这时候我们就可以运用Promise和async、await进行解决。对于依赖异步结果的代码，在Promise中，将其放在then或者catch中，在async修饰的函数中，将其放在await的后面。\n  通过上面的的代码演示，async和await解决异步实际上也是封装了Promise，并且以后只要我们看到.then和.catch的形式就能确定其原理一定是Promise，例如axios.")])])}),[],!1,null,null,null);s.default=a.exports}}]);