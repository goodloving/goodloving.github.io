(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{341:function(t,s,a){"use strict";a.r(s);var e=a(33),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue六-vue开发自定义插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue六-vue开发自定义插件"}},[t._v("#")]),t._v(" [Vue六]:vue开发自定义插件")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1-什么自定义插件（组件）"}},[t._v("1.什么自定义插件（组件）")])]),a("li",[a("a",{attrs:{href:"#_2-明确暴露install方法开发的自定义插件"}},[t._v("2.明确暴露install方法开发的自定义插件")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1、新建mytoast-vue文件"}},[t._v("1、新建MyToast.vue文件")])]),a("li",[a("a",{attrs:{href:"#_2、为mytoast-vue创建js文件封装组件（代码详解）"}},[t._v("2、为MyToast.vue创建js文件封装组件（代码详解）")])]),a("li",[a("a",{attrs:{href:"#_3、自定义插件调用和实现"}},[t._v("3、自定义插件调用和实现")])]),a("li",[a("a",{attrs:{href:"#_4、效果如图"}},[t._v("4、效果如图")])])])]),a("li",[a("a",{attrs:{href:"#_3-直接引用vue开发的自定义插件"}},[t._v("3.直接引用Vue开发的自定义插件")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1、新建mytoast-vue文件"}},[t._v("1、新建MyToast.vue文件")])]),a("li",[a("a",{attrs:{href:"#_2、为mytoast-vue创建js文件封装组件（代码详解）"}},[t._v("2、为MyToast.vue创建js文件封装组件（代码详解）")])]),a("li",[a("a",{attrs:{href:"#_3、自定义插件调用和实现"}},[t._v("3、自定义插件调用和实现")])]),a("li",[a("a",{attrs:{href:"#_4、效果如图"}},[t._v("4、效果如图")])])])]),a("li",[a("a",{attrs:{href:"#_4-两种区分与比较"}},[t._v("4.两种区分与比较")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-明确暴露install方法开发的自定义插件"}},[t._v("1.明确暴露install方法开发的自定义插件")])]),a("li",[a("a",{attrs:{href:"#_2-直接引用vue开发的自定义插件。"}},[t._v("2.直接引用Vue开发的自定义插件。")])]),a("li",[a("a",{attrs:{href:"#_3-小总结"}},[t._v("3.小总结")])])])])])]),t._v("\n  学习Vue.js有一段时间了，说下自己的感受：当初看官网的教程，对于一些不理解的或者模糊的知识点，抱着后面做项目接触后再加深学习的心态，把官网的教程匆匆过了一遍。果不其然，简单的不说，在接触项目的过程中所有的坑都是前面留下来的所谓的“"),a("strong",[t._v("不理解的或者模糊的知识点")]),t._v("”，所以只好再结合项目把Vue.js官网的文档再进一步学习，再一次后头看文档会发现整个Vue的结构都特别清晰，理解也更加深刻。自己总结出学习的方法分三步："),a("strong",[t._v("1.官方文档，2.前辈的项目代码，3.源码")]),t._v("，当然不能一概而论，适合自己的才是最好的！\n  "),a("p"),t._v(" "),a("h2",{attrs:{id:"_1-什么自定义插件（组件）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么自定义插件（组件）"}},[t._v("#")]),t._v(" 1.什么自定义插件（组件）")]),t._v(" "),a("p",[t._v("  其实我们已经用过的很多插件如：axios，vue-router等都是自定义的插件，然后被开发者普遍运用被熟知。这些插件中也可以分为两类：1.基于Vue.js基础开发的插件；2.其他插件（非Vue.js语法），而我们自己开发的插件属于第一类，基于Vue.js开发。\n  根据官网的定义，Vue.js 的插件应当有一个公开方法 "),a("strong",[t._v("install")]),t._v(" 。这个方法的第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n")])])]),a("p",[t._v("本人在学习和查阅相关资料的过程中，总结出两种不同的实现方式："),a("strong",[t._v("1.明确暴露install方法开发的自定义插件；2.直接引用Vue开发的自定义插件。")])]),t._v(" "),a("h2",{attrs:{id:"_2-明确暴露install方法开发的自定义插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-明确暴露install方法开发的自定义插件"}},[t._v("#")]),t._v(" 2.明确暴露install方法开发的自定义插件")]),t._v(" "),a("h3",{attrs:{id:"_1、新建mytoast-vue文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、新建mytoast-vue文件"}},[t._v("#")]),t._v(" 1、新建MyToast.vue文件")]),t._v(" "),a("p",[t._v("在项目目录下新建组件MyToast.vue并且定义好toast的样式，并且用两张png做不同参数的显示，当传入参数为'S'和‘F’时显示不同图片，css样式使用less格式，需要安装和导入less和less-loader第三方插件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template>\n  <div v-if="isShowToast" class="toastStyle">\n    <img v-if="showType === \'S\'" class="toastImg" src="../../assets/images/sys/right.png" alt="">\n    <img v-if="showType === \'F\'" class="toastImg" src="../../assets/images/sys/error.png" alt="">\n    <span class="toastText">{{ msg }}</span>\n  </div>\n</template>\n\n<script>\nexport default {\n  data(){\n    return{\n      isShowToast: false,\n      showType: \'S\',\n      msg: \'\'\n    }\n  }\n}\n<\/script>\n\n<style lang="less" scoped>\n.toastStyle{\n  position: fixed;\n  display: flex;\n  flex-direction: column;\n  top: 40%;\n  left: 50%;;\n  text-align: center;\n  width: 30%;\n  border-radius: 5%;\n  z-index: 100;\n  background: rgba(0, 0, 0, 0.5);\n  transform: translate(-50%,-50%);\n  .toastImg{\n    width: 100%;\n    height: 30%;\n  }\n  .toastText{\n    font-size: 25px;\n    font-weight: bold;\n    color: #000;\n  }\n}\n</style>\n')])])]),a("h3",{attrs:{id:"_2、为mytoast-vue创建js文件封装组件（代码详解）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、为mytoast-vue创建js文件封装组件（代码详解）"}},[t._v("#")]),t._v(" 2、为MyToast.vue创建js文件封装组件（代码详解）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//引入写好的MyToast.vue组件\nimport MyToast from './MyToast.vue'\n\n//声明一个变量用来存放构造器\nlet $vm\n\nexport default{\n  //调用暴露的install函数  ----------注意：此处的Vue是一个传入的形参，与第二中方法中要区分----------\n  install(Vue){\n    //变量为空执行\n    if(!$vm){\n      //调用Vue的extend方法生成一个构造器myToastConstructor继承MyToast\n      const myToastConstructor = Vue.extend(MyToast);\n      \n      //构造器实例化\n      $vm = new myToastConstructor({\n        //在构造器内部调用document生成一个div元素用来存放MyToast.vue中写好的模板template\n        el: document.createElement('div')\n      });\n      \n      //调用document将构造器和生成的div元素添加到DOM中使其能够被渲染\n      document.body.appendChild($vm.$el);\n    }\n    \n\t//首先赋值MyToast.vue中的，也就是构造器继承的是否显示toast组件的字段isShowToast 为false\n    $vm.isShowToast = false;\n    \n    //声明toast并为其声明两个方法，显示和隐藏toast\n    let toast = {\n      //show方法传入两个参数分别为显示成功或者失败，显示的信息（与MyToast.vue中的数据对应）\n      show(showType, msg){\n        $vm.isShowToast = true;\n        $vm.showType = showType;\n        $vm.msg = msg\n      },\n      //定义隐藏toast的方法\n      hide(){\n        $vm.isShowToast = false;\n      }\n    };\n    \n\t//判断Vue中是否有toast属性，没有就将上面定义好的toast赋值给Vue的属性\n    if(!Vue.toast){\n      Vue.$toast = toast;\n    }\n    \n\t//通过调用添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现全局注册\n    Vue.prototype.$toast = Vue.$toast\n  }\n}\n")])])]),a("h3",{attrs:{id:"_3、自定义插件调用和实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、自定义插件调用和实现"}},[t._v("#")]),t._v(" 3、自定义插件调用和实现")]),t._v(" "),a("p",[t._v("在main.js中引入上面写好的js文件，并注册到Vue中：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import toast from './plugins/myToast/index.js'\nVue.use(toast)\n")])])]),a("p",[t._v("在Vue项目的任何组件中可以调用定义好的组件toast：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  //假如在某个组件的mounted生命周期函数中调用\n  mounted(){\n    //通过this.$toast.show掺入参数调用显示函数\n    this.$toast.show('S','成功')\n    \n    //设置计时器2秒中后调用this.$toast.hide()隐藏toast\n    setTimeout(() => {\n      this.$toast.hide()\n    }, 2000);\n  }\n")])])]),a("h3",{attrs:{id:"_4、效果如图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、效果如图"}},[t._v("#")]),t._v(" 4、效果如图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190908222400334.gif",alt:"在这里插入图片描述"}}),t._v("\n切换到订单后在其mounted中执行toast并且2秒后自动隐藏。")]),t._v(" "),a("h2",{attrs:{id:"_3-直接引用vue开发的自定义插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-直接引用vue开发的自定义插件"}},[t._v("#")]),t._v(" 3.直接引用Vue开发的自定义插件")]),t._v(" "),a("h3",{attrs:{id:"_1、新建mytoast-vue文件-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、新建mytoast-vue文件-2"}},[t._v("#")]),t._v(" 1、新建MyToast.vue文件")]),t._v(" "),a("p",[t._v("在项目目录下新建组件MyToast.vue并且定义好toast的样式，同样用两张png做不同参数的显示（图片与二中不一样哟，做一个小小的区分），当传入参数type为'S'和‘F’时显示不同图片，css样式使用less格式，需要安装和导入less和less-loader第三方插件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<template>\n  <div id="toast" v-if="isShow" class="toast">\n    <img \n      v-if="type === \'S\'"\n      width="60px"\n      height="60px"\n      src="../../assets/sucessToast.png"\n      alt="成功" \n    />\n    <img \n      v-if="type === \'F\'"\n      width="60px"\n      height="60px"\n      src="../../assets/failToast.png"\n      alt="失败" \n    />\n    <span>{{msg}}</span>\n  </div>\n</template>\n\n<script>\nexport default {\n  data(){\n    return{\n      isShow: false,\n      msg: \'\',\n      type: \'\'\n    }\n  }\n}\n<\/script>\n<style lang="less" scoped>\n.toast{\n  position: fixed;\n  display: flex;\n  flex-direction: column;\n  top: 40%;\n  left: 50%;\n  padding: 2vw;\n  width: 35;\n  text-align: center;\n  border-radius: 5%;\n  z-index: 100;\n  background: rgba(0,0,0,0.5);\n  transform: translate(-52%,50%);\n  font-size:16px;\n}\n</style>\n')])])]),a("h3",{attrs:{id:"_2、为mytoast-vue创建js文件封装组件（代码详解）-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、为mytoast-vue创建js文件封装组件（代码详解）-2"}},[t._v("#")]),t._v(" 2、为MyToast.vue创建js文件封装组件（代码详解）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//------注意：此处导入了Vue组件，与第一种方法中的形参Vue要区分-------\nimport Vue from 'vue'\n//引入写好的MyToast.vue组件\nimport ToastComponent from './MyToast.vue'\n\n//定义构造器继承导入的ToastComponent\nconst toastConstructor = Vue.extend(ToastComponent)\n\n//定义方法showToast\nfunction showToast(text, t, duration=2000){\n  //在方法中实例化构造器定添加div元素和对ToastComponent的数据进行赋值\n  const toastDom = new toastConstructor({\n    el: document.createElement('div'),\n    data(){\n      return{\n        msg: text,\n        isShow: true,\n        type: t\n      }\n    }\n  })\n\n  //将构造器添加的元素放入DOM中使其能够被渲染\n  document.body.appendChild(toastDom.$el)\n  \n  //方法中设置定时器2秒后重新赋值sShow为false达到关闭toast的效果\n  setTimeout(() => {\n    toastDom.isShow =false\n  }, duration);\n}\n\n//定义注册方法registryToast，通过把它们添加到 Vue.prototype 上实现全局注册\nfunction registryToast(){\n  Vue.prototype.$toast = showToast\n}\n\n//最后将注册方法作为导出项\nexport default registryToast\n")])])]),a("h3",{attrs:{id:"_3、自定义插件调用和实现-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、自定义插件调用和实现-2"}},[t._v("#")]),t._v(" 3、自定义插件调用和实现")]),t._v(" "),a("p",[t._v("在main.js中引入上面写好的js文件，并注册到Vue中：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import toastPlugin from './plugins/MyToast/index.js'\nVue.use(toastPlugin)\n")])])]),a("p",[t._v("在Vue项目的任何组件中可以调用定义好的组件toast：\n在组件的template中定义一个按钮元素：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<el-button type="primary" @click="showToast">显示Toast</el-button>\n')])])]),a("p",[t._v("对按钮事件进行完善：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   methods:{\n    /**显示全局的Toast自定义组件 */\n    showToast(){\n      this.$toast(\"显示成功\", 'S')\n    }\n  },\n")])])]),a("h3",{attrs:{id:"_4、效果如图-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、效果如图-2"}},[t._v("#")]),t._v(" 4、效果如图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190908224457264.gif",alt:"在这里插入图片描述"}})]),t._v(" "),a("h2",{attrs:{id:"_4-两种区分与比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-两种区分与比较"}},[t._v("#")]),t._v(" 4.两种区分与比较")]),t._v(" "),a("p",[t._v("  上诉的两种方是大家开发插件时所用到的，现在网上的博客和资料中也都是这两种方法及一些微小的变形，但是对于两种方法的区分和详细说明并没有写道。因此上述两种方法也只是我个人的理解。现在具体说下两种方法的区别：")]),t._v(" "),a("h3",{attrs:{id:"_1-明确暴露install方法开发的自定义插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-明确暴露install方法开发的自定义插件"}},[t._v("#")]),t._v(" 1.明确暴露install方法开发的自定义插件")]),t._v(" "),a("p",[t._v("这与官方文档一致，按照其暴露的install方法，并在install方法中完成组件的封装和注册；其中inastll方法传入两个参数：Vue为必选，options为可选；并且根据方法的了解，Vue为形参。本人试着将install方法改为其他名字,如inst等,其他的不变，再次运行报错："),a("strong",[t._v("mounted函数中的show方法未定义")]),t._v(" "),a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190908230023566.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTY3OTg1,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),t._v("\n说明toast在Vue中找不到，并没有被赋值到Vue.prototype 属性上，所以install可以看作是Vue开发插件注册的默认“入口”，修改名字后Vue就无法识别或者找不到对应的函数，所以install必须给出且插件的封装和注册在其方法中完成！")]),t._v(" "),a("h3",{attrs:{id:"_2-直接引用vue开发的自定义插件。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-直接引用vue开发的自定义插件。"}},[t._v("#")]),t._v(" 2.直接引用Vue开发的自定义插件。")]),t._v(" "),a("p",[t._v("对于该方法，我们发现并没有使用install方法，但是他却能执行，你说奇怪不奇怪！于是冲代码上面进行分析：在第二和第三部分代码详解时已经有过交代，"),a("strong",[t._v("调用暴露的install函数时“Vue”是一个传入的形参，而此方法中注意是导入了Vue组件"),a("code",[t._v("import Vue from 'vue'")]),t._v("，与第一种方法中的形参Vue要区分")]),t._v("。本人没有看过Vue的源码，所以一不知道个所以然，因此只能猜测在此方法中引入了Vue，vue中已经默认调用了insatll方法，然后在：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function registryToast(){\n  Vue.prototype.$toast = showToast\n}\n")])])]),a("p",[t._v("中将自定义的showToast方法赋值给Vue.prototype.的属性，然后再放入默认调用的Vue的install中！")]),t._v(" "),a("h3",{attrs:{id:"_3-小总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-小总结"}},[t._v("#")]),t._v(" 3.小总结")]),t._v(" "),a("p",[a("strong",[t._v("当然这只是一个猜测，或许上述的两种方法其实就是一种方法，第二种方法是第一种方法的变形形式，希望有大佬能够解释下！")])]),t._v(" "),a("p",[t._v("欢迎大家关注本人的微信公众号，微信公众号将不定期发送相应学习文章和教程")]),t._v(" "),a("p",[a("strong",[a("center",[t._v("微信号：chiyizao")])],1),t._v(" "),a("center",[t._v("或者微信公众号搜索：")]),a("center",[t._v("迟亦早")]),t._v(" "),a("strong",[a("center",[t._v("二维码")])],1),t._v(" "),a("center",[a("img",{staticStyle:{height:"250px",width:"250px"},attrs:{src:"/vxgzhcode.jpg"}})])],1)])}),[],!1,null,null,null);s.default=n.exports}}]);